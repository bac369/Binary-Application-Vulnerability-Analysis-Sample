# Part 1
Note: Each screenshot has the time, either printed in the terminal window using `date` or at the top of the VM window.
## Task 1: Shellcode
Compiled the code using `make`. Then ran `./a32.out` and `./a64.out`. Both launched a shell without root permissions.
![Pic1](artifacts/bac369-task1-1.png)
## Task 2: Vulnerable Program
Compiled the code using `make` in the code folder.
![Pic2](artifacts/bac369-task2-1.png)

## Task 3: Launching Attack (32-bit)
Added the start line to insert the inside the payload within the range of the buffer 517.
As seen in the picture below, I found the addresses of the buffer and $ebp. I subtracted their values 0xb28 - 0xabc = 108. Then added 4 to the offset to get the next value.
The ret value has to hit the NOP sled somewhere above the beginning of the buffer address. Accounting for the address space used by gdb, I tried +8, + 64, and + 120. I found the value 120 was successful.

![Pic2](artifacts/bac369-task3-1.png)
![Pic2](artifacts/bac369-task3-2.png)

## Task 5: 64 bit
Process:
1. ### Find Offset
   I started by finding the rbp and buffer addresses. Using gbd I found their values and subtracted them `0x960 - 0x890 = 208`. I added 8 to that since return address is 8 above rbp on the stack. I found my offset.
   ![Pic2](artifacts/bac369-task5-3.png)
2. ### Overcome 0000 in strcpy()
   I played around with different inputs in gdb, and I realized that if i just didn't put any 0's at all in the return address. It worked fine. I believe this works that area of memory had 0's occupying that space so there was no need to overwrite them. The unfinished return address was `0x7fffffffd960` the location of the buffer.
3. ### Finding Proper Return address
Like in the 32 bit, since the NOP sled sits somewhere above the input buffer I need to find where. I struggled here. I tried to be lazy and simply try values similar to the 32-bit, but I wasn't having luck. I turned to gdb. I ran the debugger, stepped through, and used `x/1000h 0x7fffffffd60`to see the stack. I saw that the NOP sled didn't even start until about `0xd90`. I was overflowing far too short. I also the address of `ret` in the NOP sled, so I had to get past that too to sled into shellcode. I finally got shell using `ret = 0x7fffffffd960 + 1600`.

![Pic2](artifacts/bac369-task5-1.png)

## Task 7: Vulnerable Program
### Experiment:
Without setuid, it opens a dash shell without root privilege ($). With the setuid the dash shell has root privilege (#). This happens because the setuid bit makes the binary root owned, without it, it is a non-root shell.
![Pic2](artifacts/bac369-task7-1.png)
### Launching the Attack Again
I inputting the updated setuid shellcode into expoit32.py and ran the exploit. As you can see below the shell countermeasure was beaten.

![Pic2](artifacts/bac369-task7-2.png)

## Task 8: Defeating Address Randomization
Ran `bash defeat-aslr.sh` for an hour and could not break-in. I believe I was using the old broken code. I later came back a reattempted using the fixed bruteforce code. This time it worked. The program toook 1714 attempts and each failed attempt caused a segmentation fault. This is because it was overflowing to random addresses that crashsed the program. The time it succeeds is when it fits the exact address I coded in `exploit32.py`. even thought the addresses are randomized, the offset and relative locations to each other on the stack are not.
![Pic2](artifacts/bac369-task8-1.png)

## Task 9: Other Countermeasures
### 9a
Ran `./stack-L1` without StackGuard again and it ran fine. I then editted the `makefile` to remove the `-fnostack-protector` from compliation. Now with StackGuard on I attempted my previously successful `./stack-L1`. However, with StackGuard iwas alerted with `*** stack smashing detected ***` and the program aborted. Upon researching, I learned that StackGuard uses a canary value that detects overflows. If the value is overwritten or destroyed by an overflow the program aborts, which is exactly what happened here.
![Pic2](artifacts/bac369-task9-1.png)
### 9b
Altered the makefile and recompiled using `-z noexecstack`. Attempted to run `./a32.out` or `./a64.out` results in Segmentation Faults.This is due to the noexecstack prohibiting execution on the stack. NX is used to prevent overflow attacks by making code on the stack nonexecutable. This is particularly good at preventing unauthorized shellcode as we are doing here by not allowing the shellcode to execute on the stack.
![Pic2](artifacts/bac369-task9-2.png)
